模块化是一种思想，与语言无关，世间万物皆可模块化。js的模块化正是因为大前端的到来，巨型项目变得原来越多，js库之间的依赖无法轻松管理所诞生的产物，理解这一点，学习模块化时会更深刻。

### 问题引出

浏览器会解释执行html引入的js脚本，假设某页面引入了两个js脚本a.js与b.js
a.js
```javascript
var pi = 3.14;
function primeter(r){
    reutrn pi * 2 * r;
}
```
b.js
```javascript
var pi = 3.1415926;
function area(r){
    return pi * r * r;
}
```
a.js提供了计算圆周长的函数，b.js提供了计算圆面积的函数，但是两位脚本开发者似乎对于圆周率PI的精度要求不一样，a.js只要求粗略值，而b.js需要更为精确的值，现在问题来了：

**如果调用者分别调用求周长与求面积的函数求一个半径为3的圆的周长与面积，那么结果会是什么？**

结果如下：
> 周长: 18.849555600000002
面积: 28.274333400000003

结果是计算周长时使用了b.js中较为精确的PI值，为什么？
因为a.js与b.js中的变量pi都作为了全局对象window的属性存储，因此，在b.js脚本执行时必然会覆盖掉window的pi属性，这就是臭名昭著的**js全局变量污染问题**。这个问题可能导致的问题远比上述例子要严重，通常我们项目中会依赖很多js库，如果这些库作者都随意在window下声明变量，那么结果就是变量的值被覆盖来覆盖去，这样一来，整个项目基本就无法运行了。

### 问题解决

那么，如何解决这个问题呢？解决这个问题要使用到js**闭包**的知识。
> 请注意，闭包是一种编程思想，不是只有js才有闭包，诸如python等**函数式编程语言**皆有闭包的概念。闭包的详细文档可参考：[闭包-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E9%97%AD%E5%8C%85)

利用闭包知识，我们新编写的代码如下所示：
a.js
```javascript
var a = (function(){
    var pi = 3.14;
    
    return {
        primeter: function(r){
            return pi * 2 * r;
        }
    }
})();
```
b.js
```javascript
var b = (function(){
    var pi = 3.1415926;

    return {
        area: function(r){
            return pi * r * r;
        }
    }
})()
```
简单看一下代码的结构，第一对括号将一个完整的函数定义包含起来，第二对括号则紧随其后，这是什么意思呢？
首先，我们用括号将语句包含起来一般是获取复杂表达式的结果，例如：
```
var a = 1, b = 2;
var c = a > 1 ? (a + b) : (a + b)
```
这里的`(a+b)`与`(function(){})`是没有任何区别的，因为js是函数式编程，一个函数的定义就是一个变量，它可以像变量一样被传递、使用，所以用大括号包住一个函数定义就是将这个函数定义作为一个变量看待。
第一对括号我们清楚了，它的作用是**获取括号内函数的引用**，知道这个作用后，第二对括号就好理解了，因为第一对括号实际就是一个函数的声明，那么第二对括号就是执行这个函数。

所以整个代码的语义我们也清楚了：以a.js为例，变量a等于第一对括号内的匿名函数执行的返回值，该值为一个对象，该对象有一个属性`primeter`是一个函数，其签名与前面提到的一致。所以，我们可以很方便地使用a与b这个对象来获取圆的周长与面积，代码如下：
```javascript
console.log('周长: ' + a.primeter(3))
console.log('面积: ' + b.area(3))
```
其执行结果如下所示：
> 周长: 18.84
面积: 28.274333400000003

这里的执行结果是我们想要的样子，这是因为a.js与b.js的闭包下都维护了一个不同的pi值，这两个pi值都处于不同闭包的局部作用域下，所以不会污染全局作用域。

现在window的结构为：
```javascript
window = {
    a: {
        primeter: function(r){}
    },
    b: {
        area: function(r){}
    }
}
```

**笔者认为，这就是模块化的雏形。在这个例子里，我们可以将a、b两个变量视为两个模块，模块下的字段就是其抛出的接口，模块定义的匿名函数为其实现。**
**这也符合现实生活的规律，模块像一个黑盒子，它只提供接口给外部调用，调用者无需关心内部的实现。从这一点出发，模块的思想又是面向对象的思想，模块的抛出是接口，模块的实现对应接口的实现。**

### 更优美的解决方案 - es6模块化

es6的出现就是为了解决前端巨型项目所带来的种种问题，其中模块化就是第一个需要被解决的问题。现在，让我们看看使用es6的模块化，如何处理上述问题：

moduleA.js
```javascript
const pi = 3.14;

export default function primeter(r){
    return pi * 2 * r;
}
```

moduleB.js
```javascript
const pi = 3.1415926;

export default function area(r){
    return pi * r * r;
}
```

然后，我们可以按需引入模块来使用：
```javascript
import primeter from './moduleA.js'
import area from './moduleB.js'

console.log('周长: ' + primeter(3))
console.log('面积: ' + area(3))
```

这里的`from './moduleA.js'`就类似于我们使用`<script>`标签引入js脚本，而`import primeter`就类似于获取模块下的接口，如上所述的`primeter`就是一个计算圆周长的接口。

我们暂且认为es6的模块化的底层原理也是闭包，因此可以进一步认为模块化是ECMAScript为开发者提供的一种封装，它的好处是：
- 语言级别的模块化，我们无需操心模块的实现细节，只需要知道怎么用即可；
- 规范化。基于闭包，10个人能写出10种模块化的实现，这样不利于形成规范。


